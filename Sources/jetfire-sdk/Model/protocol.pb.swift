// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Sources/jetfire-sdk/Model/protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct JetFireTimestamp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unix timestamp (milliseconds)
  public var value: Int64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Int64? = nil
}

public struct JetFireEventType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 - custom
  /// 1 - first_launch
  /// 2 - application_start
  /// 3 - application_shutdown
  /// 4 - feature_open
  /// 5 - feature_close
  /// 6 - feature_use
  /// 7 - story_open
  /// 8 - story_tap
  /// 9 - story_close
  /// 10 - push_show
  /// 11 - push_tap
  /// 12 - push_close
  /// 13 - toaster_show
  /// 14 - toaster_tap
  /// 15 - toaster_close
  /// 16 - feature_accepted
  public var value: Int64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Int64? = nil
}

public struct JetFireActionType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1 – deeplink
  /// 2 – stories
  public var value: Int64 {
    get {return _value ?? 0}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Int64? = nil
}

public struct JetFireAnyValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var int: Int32 {
    get {return _int ?? 0}
    set {_int = newValue}
  }
  /// Returns true if `int` has been explicitly set.
  public var hasInt: Bool {return self._int != nil}
  /// Clears the value of `int`. Subsequent reads from it will return its default value.
  public mutating func clearInt() {self._int = nil}

  public var long: Int64 {
    get {return _long ?? 0}
    set {_long = newValue}
  }
  /// Returns true if `long` has been explicitly set.
  public var hasLong: Bool {return self._long != nil}
  /// Clears the value of `long`. Subsequent reads from it will return its default value.
  public mutating func clearLong() {self._long = nil}

  public var double: Double {
    get {return _double ?? 0}
    set {_double = newValue}
  }
  /// Returns true if `double` has been explicitly set.
  public var hasDouble: Bool {return self._double != nil}
  /// Clears the value of `double`. Subsequent reads from it will return its default value.
  public mutating func clearDouble() {self._double = nil}

  public var bool: Bool {
    get {return _bool ?? false}
    set {_bool = newValue}
  }
  /// Returns true if `bool` has been explicitly set.
  public var hasBool: Bool {return self._bool != nil}
  /// Clears the value of `bool`. Subsequent reads from it will return its default value.
  public mutating func clearBool() {self._bool = nil}

  public var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  public var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  public mutating func clearString() {self._string = nil}

  public var json: String {
    get {return _json ?? String()}
    set {_json = newValue}
  }
  /// Returns true if `json` has been explicitly set.
  public var hasJson: Bool {return self._json != nil}
  /// Clears the value of `json`. Subsequent reads from it will return its default value.
  public mutating func clearJson() {self._json = nil}

  public var bytes: Data {
    get {return _bytes ?? Data()}
    set {_bytes = newValue}
  }
  /// Returns true if `bytes` has been explicitly set.
  public var hasBytes: Bool {return self._bytes != nil}
  /// Clears the value of `bytes`. Subsequent reads from it will return its default value.
  public mutating func clearBytes() {self._bytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _int: Int32? = nil
  fileprivate var _long: Int64? = nil
  fileprivate var _double: Double? = nil
  fileprivate var _bool: Bool? = nil
  fileprivate var _string: String? = nil
  fileprivate var _json: String? = nil
  fileprivate var _bytes: Data? = nil
}

public struct JetFireLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lat: Double {
    get {return _lat ?? 0}
    set {_lat = newValue}
  }
  /// Returns true if `lat` has been explicitly set.
  public var hasLat: Bool {return self._lat != nil}
  /// Clears the value of `lat`. Subsequent reads from it will return its default value.
  public mutating func clearLat() {self._lat = nil}

  public var lon: Double {
    get {return _lon ?? 0}
    set {_lon = newValue}
  }
  /// Returns true if `lon` has been explicitly set.
  public var hasLon: Bool {return self._lon != nil}
  /// Clears the value of `lon`. Subsequent reads from it will return its default value.
  public mutating func clearLon() {self._lon = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lat: Double? = nil
  fileprivate var _lon: Double? = nil
}

public struct JetFireScreen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  public var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  public mutating func clearWidth() {self._width = nil}

  public var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  public var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  public mutating func clearHeight() {self._height = nil}

  public var dpi: Int32 {
    get {return _dpi ?? 0}
    set {_dpi = newValue}
  }
  /// Returns true if `dpi` has been explicitly set.
  public var hasDpi: Bool {return self._dpi != nil}
  /// Clears the value of `dpi`. Subsequent reads from it will return its default value.
  public mutating func clearDpi() {self._dpi = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _width: Int32? = nil
  fileprivate var _height: Int32? = nil
  fileprivate var _dpi: Int32? = nil
}

public struct JetFireProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var value: JetFireAnyValue {
    get {return _value ?? JetFireAnyValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: JetFireAnyValue? = nil
}

public struct JetFireImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var previewURL: String {
    get {return _previewURL ?? String()}
    set {_previewURL = newValue}
  }
  /// Returns true if `previewURL` has been explicitly set.
  public var hasPreviewURL: Bool {return self._previewURL != nil}
  /// Clears the value of `previewURL`. Subsequent reads from it will return its default value.
  public mutating func clearPreviewURL() {self._previewURL = nil}

  /// base url, url for other screens will be down there
  public var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _previewURL: String? = nil
  fileprivate var _url: String? = nil
}

public struct JetFireAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: JetFireActionType {
    get {return _type ?? JetFireActionType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var deeplink: String {
    get {return _deeplink ?? String()}
    set {_deeplink = newValue}
  }
  /// Returns true if `deeplink` has been explicitly set.
  public var hasDeeplink: Bool {return self._deeplink != nil}
  /// Clears the value of `deeplink`. Subsequent reads from it will return its default value.
  public mutating func clearDeeplink() {self._deeplink = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: JetFireActionType? = nil
  fileprivate var _deeplink: String? = nil
}

public struct JetFireSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var atTime: JetFireTimestamp {
    get {return _atTime ?? JetFireTimestamp()}
    set {_atTime = newValue}
  }
  /// Returns true if `atTime` has been explicitly set.
  public var hasAtTime: Bool {return self._atTime != nil}
  /// Clears the value of `atTime`. Subsequent reads from it will return its default value.
  public mutating func clearAtTime() {self._atTime = nil}

  /// seconds
  public var after: Int64 {
    get {return _after ?? 0}
    set {_after = newValue}
  }
  /// Returns true if `after` has been explicitly set.
  public var hasAfter: Bool {return self._after != nil}
  /// Clears the value of `after`. Subsequent reads from it will return its default value.
  public mutating func clearAfter() {self._after = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _atTime: JetFireTimestamp? = nil
  fileprivate var _after: Int64? = nil
}

public struct JetFirePropertySet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var value: JetFireAnyValue {
    get {return _value ?? JetFireAnyValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: JetFireAnyValue? = nil
}

public struct JetFirePropertyRemove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

public struct JetFirePropertyIncrement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var increment: Double {
    get {return _increment ?? 0}
    set {_increment = newValue}
  }
  /// Returns true if `increment` has been explicitly set.
  public var hasIncrement: Bool {return self._increment != nil}
  /// Clears the value of `increment`. Subsequent reads from it will return its default value.
  public mutating func clearIncrement() {self._increment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _increment: Double? = nil
}

public struct JetFirePropertyDecrement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var decrement: Double {
    get {return _decrement ?? 0}
    set {_decrement = newValue}
  }
  /// Returns true if `decrement` has been explicitly set.
  public var hasDecrement: Bool {return self._decrement != nil}
  /// Clears the value of `decrement`. Subsequent reads from it will return its default value.
  public mutating func clearDecrement() {self._decrement = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _decrement: Double? = nil
}

public struct JetFirePropertyOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operation: JetFirePropertyOperation.OneOf_Operation? = nil

  public var set: JetFirePropertySet {
    get {
      if case .set(let v)? = operation {return v}
      return JetFirePropertySet()
    }
    set {operation = .set(newValue)}
  }

  public var remove: JetFirePropertyRemove {
    get {
      if case .remove(let v)? = operation {return v}
      return JetFirePropertyRemove()
    }
    set {operation = .remove(newValue)}
  }

  public var increment: JetFirePropertyIncrement {
    get {
      if case .increment(let v)? = operation {return v}
      return JetFirePropertyIncrement()
    }
    set {operation = .increment(newValue)}
  }

  public var decrement: JetFirePropertyDecrement {
    get {
      if case .decrement(let v)? = operation {return v}
      return JetFirePropertyDecrement()
    }
    set {operation = .decrement(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable {
    case set(JetFirePropertySet)
    case remove(JetFirePropertyRemove)
    case increment(JetFirePropertyIncrement)
    case decrement(JetFirePropertyDecrement)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .set: return {
        guard case .set(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .remove: return {
        guard case .remove(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .increment: return {
        guard case .increment(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .decrement: return {
        guard case .decrement(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: JetFirePropertyOperation.OneOf_Operation, rhs: JetFirePropertyOperation.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remove, .remove): return {
        guard case .remove(let l) = lhs, case .remove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.increment, .increment): return {
        guard case .increment(let l) = lhs, case .increment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decrement, .decrement): return {
        guard case .decrement(let l) = lhs, case .decrement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct JetFireApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: String? = nil
}

public struct JetFireSdk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: String? = nil
}

public struct JetFireDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ios, android
  public var platform: String {
    get {return _platform ?? String()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {self._platform = nil}

  /// apple
  public var vendor: String {
    get {return _vendor ?? String()}
    set {_vendor = newValue}
  }
  /// Returns true if `vendor` has been explicitly set.
  public var hasVendor: Bool {return self._vendor != nil}
  /// Clears the value of `vendor`. Subsequent reads from it will return its default value.
  public mutating func clearVendor() {self._vendor = nil}

  /// iphone,13
  public var model: String {
    get {return _model ?? String()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {self._model = nil}

  /// ios
  public var os: String {
    get {return _os ?? String()}
    set {_os = newValue}
  }
  /// Returns true if `os` has been explicitly set.
  public var hasOs: Bool {return self._os != nil}
  /// Clears the value of `os`. Subsequent reads from it will return its default value.
  public mutating func clearOs() {self._os = nil}

  /// 14.1.1
  public var osVersion: String {
    get {return _osVersion ?? String()}
    set {_osVersion = newValue}
  }
  /// Returns true if `osVersion` has been explicitly set.
  public var hasOsVersion: Bool {return self._osVersion != nil}
  /// Clears the value of `osVersion`. Subsequent reads from it will return its default value.
  public mutating func clearOsVersion() {self._osVersion = nil}

  /// for android
  public var firmware: String {
    get {return _firmware ?? String()}
    set {_firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  public var hasFirmware: Bool {return self._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  public mutating func clearFirmware() {self._firmware = nil}

  /// ru
  public var language: String {
    get {return _language ?? String()}
    set {_language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  public var hasLanguage: Bool {return self._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  public mutating func clearLanguage() {self._language = nil}

  /// ru_RU
  public var locale: String {
    get {return _locale ?? String()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  public var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  public mutating func clearLocale() {self._locale = nil}

  /// Europe/Moscow
  public var timeZone: String {
    get {return _timeZone ?? String()}
    set {_timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  public var hasTimeZone: Bool {return self._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZone() {self._timeZone = nil}

  public var carrier: [String] = []

  public var screen: JetFireScreen {
    get {return _screen ?? JetFireScreen()}
    set {_screen = newValue}
  }
  /// Returns true if `screen` has been explicitly set.
  public var hasScreen: Bool {return self._screen != nil}
  /// Clears the value of `screen`. Subsequent reads from it will return its default value.
  public mutating func clearScreen() {self._screen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _platform: String? = nil
  fileprivate var _vendor: String? = nil
  fileprivate var _model: String? = nil
  fileprivate var _os: String? = nil
  fileprivate var _osVersion: String? = nil
  fileprivate var _firmware: String? = nil
  fileprivate var _language: String? = nil
  fileprivate var _locale: String? = nil
  fileprivate var _timeZone: String? = nil
  fileprivate var _screen: JetFireScreen? = nil
}

public struct JetFireRequestUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: String? = nil
}

public struct JetFireUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var properties: [JetFireProperty] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: String? = nil
}

public struct JetFireRequestSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: String? = nil
}

public struct JetFireSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String {
    get {return _storage._uuid ?? String()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  /// milliseconds
  public var timestamp: JetFireTimestamp {
    get {return _storage._timestamp ?? JetFireTimestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var app: JetFireApp {
    get {return _storage._app ?? JetFireApp()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {_uniqueStorage()._app = nil}

  public var sdk: JetFireSdk {
    get {return _storage._sdk ?? JetFireSdk()}
    set {_uniqueStorage()._sdk = newValue}
  }
  /// Returns true if `sdk` has been explicitly set.
  public var hasSdk: Bool {return _storage._sdk != nil}
  /// Clears the value of `sdk`. Subsequent reads from it will return its default value.
  public mutating func clearSdk() {_uniqueStorage()._sdk = nil}

  public var device: JetFireDevice {
    get {return _storage._device ?? JetFireDevice()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  public var location: JetFireLocation {
    get {return _storage._location ?? JetFireLocation()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  public var properties: [JetFireProperty] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct JetFireFeaturesSql {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stories: String {
    get {return _stories ?? String()}
    set {_stories = newValue}
  }
  /// Returns true if `stories` has been explicitly set.
  public var hasStories: Bool {return self._stories != nil}
  /// Clears the value of `stories`. Subsequent reads from it will return its default value.
  public mutating func clearStories() {self._stories = nil}

  public var trigger: String {
    get {return _trigger ?? String()}
    set {_trigger = newValue}
  }
  /// Returns true if `trigger` has been explicitly set.
  public var hasTrigger: Bool {return self._trigger != nil}
  /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
  public mutating func clearTrigger() {self._trigger = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stories: String? = nil
  fileprivate var _trigger: String? = nil
}

public struct JetFireFeatureButton {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var action: JetFireAction {
    get {return _action ?? JetFireAction()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _title: String? = nil
  fileprivate var _action: JetFireAction? = nil
}

public struct JetFireFeaturePush {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var subtitle: String {
    get {return _subtitle ?? String()}
    set {_subtitle = newValue}
  }
  /// Returns true if `subtitle` has been explicitly set.
  public var hasSubtitle: Bool {return self._subtitle != nil}
  /// Clears the value of `subtitle`. Subsequent reads from it will return its default value.
  public mutating func clearSubtitle() {self._subtitle = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var image: JetFireImage {
    get {return _image ?? JetFireImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var actionButton: JetFireFeatureButton {
    get {return _actionButton ?? JetFireFeatureButton()}
    set {_actionButton = newValue}
  }
  /// Returns true if `actionButton` has been explicitly set.
  public var hasActionButton: Bool {return self._actionButton != nil}
  /// Clears the value of `actionButton`. Subsequent reads from it will return its default value.
  public mutating func clearActionButton() {self._actionButton = nil}

  public var schedule: JetFireSchedule {
    get {return _schedule ?? JetFireSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var expire: JetFireSchedule {
    get {return _expire ?? JetFireSchedule()}
    set {_expire = newValue}
  }
  /// Returns true if `expire` has been explicitly set.
  public var hasExpire: Bool {return self._expire != nil}
  /// Clears the value of `expire`. Subsequent reads from it will return its default value.
  public mutating func clearExpire() {self._expire = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _title: String? = nil
  fileprivate var _subtitle: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _image: JetFireImage? = nil
  fileprivate var _actionButton: JetFireFeatureButton? = nil
  fileprivate var _schedule: JetFireSchedule? = nil
  fileprivate var _expire: JetFireSchedule? = nil
}

public struct JetFireFeatureToaster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var subtitle: String {
    get {return _subtitle ?? String()}
    set {_subtitle = newValue}
  }
  /// Returns true if `subtitle` has been explicitly set.
  public var hasSubtitle: Bool {return self._subtitle != nil}
  /// Clears the value of `subtitle`. Subsequent reads from it will return its default value.
  public mutating func clearSubtitle() {self._subtitle = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var image: JetFireImage {
    get {return _image ?? JetFireImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var actionButton: JetFireFeatureButton {
    get {return _actionButton ?? JetFireFeatureButton()}
    set {_actionButton = newValue}
  }
  /// Returns true if `actionButton` has been explicitly set.
  public var hasActionButton: Bool {return self._actionButton != nil}
  /// Clears the value of `actionButton`. Subsequent reads from it will return its default value.
  public mutating func clearActionButton() {self._actionButton = nil}

  public var hideButton: JetFireFeatureButton {
    get {return _hideButton ?? JetFireFeatureButton()}
    set {_hideButton = newValue}
  }
  /// Returns true if `hideButton` has been explicitly set.
  public var hasHideButton: Bool {return self._hideButton != nil}
  /// Clears the value of `hideButton`. Subsequent reads from it will return its default value.
  public mutating func clearHideButton() {self._hideButton = nil}

  public var schedule: JetFireSchedule {
    get {return _schedule ?? JetFireSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var expire: JetFireSchedule {
    get {return _expire ?? JetFireSchedule()}
    set {_expire = newValue}
  }
  /// Returns true if `expire` has been explicitly set.
  public var hasExpire: Bool {return self._expire != nil}
  /// Clears the value of `expire`. Subsequent reads from it will return its default value.
  public mutating func clearExpire() {self._expire = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _title: String? = nil
  fileprivate var _subtitle: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _image: JetFireImage? = nil
  fileprivate var _actionButton: JetFireFeatureButton? = nil
  fileprivate var _hideButton: JetFireFeatureButton? = nil
  fileprivate var _schedule: JetFireSchedule? = nil
  fileprivate var _expire: JetFireSchedule? = nil
}

public struct JetFireFeatureStoryFrameBackground {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var color: String {
    get {return _color ?? String()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {self._color = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _color: String? = nil
}

public struct JetFireFeatureStoryFrameFont {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var color: String {
    get {return _color ?? String()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {self._color = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _color: String? = nil
}

public struct JetFireFeatureStoryCover {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var image: JetFireImage {
    get {return _image ?? JetFireImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: JetFireImage? = nil
  fileprivate var _title: String? = nil
}

public struct JetFireFeatureStorySettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alwaysRewind: Bool {
    get {return _alwaysRewind ?? false}
    set {_alwaysRewind = newValue}
  }
  /// Returns true if `alwaysRewind` has been explicitly set.
  public var hasAlwaysRewind: Bool {return self._alwaysRewind != nil}
  /// Clears the value of `alwaysRewind`. Subsequent reads from it will return its default value.
  public mutating func clearAlwaysRewind() {self._alwaysRewind = nil}

  /// seconds
  public var afterReadExpire: Int64 {
    get {return _afterReadExpire ?? 0}
    set {_afterReadExpire = newValue}
  }
  /// Returns true if `afterReadExpire` has been explicitly set.
  public var hasAfterReadExpire: Bool {return self._afterReadExpire != nil}
  /// Clears the value of `afterReadExpire`. Subsequent reads from it will return its default value.
  public mutating func clearAfterReadExpire() {self._afterReadExpire = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _alwaysRewind: Bool? = nil
  fileprivate var _afterReadExpire: Int64? = nil
}

public struct JetFireFeatureStoryFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var subtitle: String {
    get {return _subtitle ?? String()}
    set {_subtitle = newValue}
  }
  /// Returns true if `subtitle` has been explicitly set.
  public var hasSubtitle: Bool {return self._subtitle != nil}
  /// Clears the value of `subtitle`. Subsequent reads from it will return its default value.
  public mutating func clearSubtitle() {self._subtitle = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var image: JetFireImage {
    get {return _image ?? JetFireImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  public var background: JetFireFeatureStoryFrameBackground {
    get {return _background ?? JetFireFeatureStoryFrameBackground()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  public var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  public mutating func clearBackground() {self._background = nil}

  public var font: JetFireFeatureStoryFrameFont {
    get {return _font ?? JetFireFeatureStoryFrameFont()}
    set {_font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  public var hasFont: Bool {return self._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  public mutating func clearFont() {self._font = nil}

  public var actionButton: JetFireFeatureButton {
    get {return _actionButton ?? JetFireFeatureButton()}
    set {_actionButton = newValue}
  }
  /// Returns true if `actionButton` has been explicitly set.
  public var hasActionButton: Bool {return self._actionButton != nil}
  /// Clears the value of `actionButton`. Subsequent reads from it will return its default value.
  public mutating func clearActionButton() {self._actionButton = nil}

  public var hideButton: JetFireFeatureButton {
    get {return _hideButton ?? JetFireFeatureButton()}
    set {_hideButton = newValue}
  }
  /// Returns true if `hideButton` has been explicitly set.
  public var hasHideButton: Bool {return self._hideButton != nil}
  /// Clears the value of `hideButton`. Subsequent reads from it will return its default value.
  public mutating func clearHideButton() {self._hideButton = nil}

  public var duration: Int32 {
    get {return _duration ?? 0}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _title: String? = nil
  fileprivate var _subtitle: String? = nil
  fileprivate var _message: String? = nil
  fileprivate var _image: JetFireImage? = nil
  fileprivate var _background: JetFireFeatureStoryFrameBackground? = nil
  fileprivate var _font: JetFireFeatureStoryFrameFont? = nil
  fileprivate var _actionButton: JetFireFeatureButton? = nil
  fileprivate var _hideButton: JetFireFeatureButton? = nil
  fileprivate var _duration: Int32? = nil
}

public struct JetFireFeatureStory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var cover: JetFireFeatureStoryCover {
    get {return _cover ?? JetFireFeatureStoryCover()}
    set {_cover = newValue}
  }
  /// Returns true if `cover` has been explicitly set.
  public var hasCover: Bool {return self._cover != nil}
  /// Clears the value of `cover`. Subsequent reads from it will return its default value.
  public mutating func clearCover() {self._cover = nil}

  public var frames: [JetFireFeatureStoryFrame] = []

  public var schedule: JetFireSchedule {
    get {return _schedule ?? JetFireSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var expire: JetFireSchedule {
    get {return _expire ?? JetFireSchedule()}
    set {_expire = newValue}
  }
  /// Returns true if `expire` has been explicitly set.
  public var hasExpire: Bool {return self._expire != nil}
  /// Clears the value of `expire`. Subsequent reads from it will return its default value.
  public mutating func clearExpire() {self._expire = nil}

  public var settings: JetFireFeatureStorySettings {
    get {return _settings ?? JetFireFeatureStorySettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {self._settings = nil}

  public var priority: Int64 {
    get {return _priority ?? 0}
    set {_priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  public var hasPriority: Bool {return self._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  public mutating func clearPriority() {self._priority = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _cover: JetFireFeatureStoryCover? = nil
  fileprivate var _schedule: JetFireSchedule? = nil
  fileprivate var _expire: JetFireSchedule? = nil
  fileprivate var _settings: JetFireFeatureStorySettings? = nil
  fileprivate var _priority: Int64? = nil
}

public struct JetFireFeatureData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data {
    get {return _data ?? Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var schedule: JetFireSchedule {
    get {return _schedule ?? JetFireSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {self._schedule = nil}

  public var expire: JetFireSchedule {
    get {return _expire ?? JetFireSchedule()}
    set {_expire = newValue}
  }
  /// Returns true if `expire` has been explicitly set.
  public var hasExpire: Bool {return self._expire != nil}
  /// Clears the value of `expire`. Subsequent reads from it will return its default value.
  public mutating func clearExpire() {self._expire = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Data? = nil
  fileprivate var _schedule: JetFireSchedule? = nil
  fileprivate var _expire: JetFireSchedule? = nil
}

public struct JetFireEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String {
    get {return _uuid ?? String()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  public var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  public mutating func clearUuid() {self._uuid = nil}

  /// milliseconds
  public var timestamp: JetFireTimestamp {
    get {return _timestamp ?? JetFireTimestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var eventType: JetFireEventType {
    get {return _eventType ?? JetFireEventType()}
    set {_eventType = newValue}
  }
  /// Returns true if `eventType` has been explicitly set.
  public var hasEventType: Bool {return self._eventType != nil}
  /// Clears the value of `eventType`. Subsequent reads from it will return its default value.
  public mutating func clearEventType() {self._eventType = nil}

  public var customEvent: String {
    get {return _customEvent ?? String()}
    set {_customEvent = newValue}
  }
  /// Returns true if `customEvent` has been explicitly set.
  public var hasCustomEvent: Bool {return self._customEvent != nil}
  /// Clears the value of `customEvent`. Subsequent reads from it will return its default value.
  public mutating func clearCustomEvent() {self._customEvent = nil}

  public var feature: String {
    get {return _feature ?? String()}
    set {_feature = newValue}
  }
  /// Returns true if `feature` has been explicitly set.
  public var hasFeature: Bool {return self._feature != nil}
  /// Clears the value of `feature`. Subsequent reads from it will return its default value.
  public mutating func clearFeature() {self._feature = nil}

  public var campaignID: Int64 {
    get {return _campaignID ?? 0}
    set {_campaignID = newValue}
  }
  /// Returns true if `campaignID` has been explicitly set.
  public var hasCampaignID: Bool {return self._campaignID != nil}
  /// Clears the value of `campaignID`. Subsequent reads from it will return its default value.
  public mutating func clearCampaignID() {self._campaignID = nil}

  /// story_id, ...
  public var entityID: Int64 {
    get {return _entityID ?? 0}
    set {_entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return self._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {self._entityID = nil}

  public var properties: [JetFireProperty] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _uuid: String? = nil
  fileprivate var _timestamp: JetFireTimestamp? = nil
  fileprivate var _eventType: JetFireEventType? = nil
  fileprivate var _customEvent: String? = nil
  fileprivate var _feature: String? = nil
  fileprivate var _campaignID: Int64? = nil
  fileprivate var _entityID: Int64? = nil
}

public struct JetFireCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var push: JetFireFeaturePush {
    get {return _storage._push ?? JetFireFeaturePush()}
    set {_uniqueStorage()._push = newValue}
  }
  /// Returns true if `push` has been explicitly set.
  public var hasPush: Bool {return _storage._push != nil}
  /// Clears the value of `push`. Subsequent reads from it will return its default value.
  public mutating func clearPush() {_uniqueStorage()._push = nil}

  public var toaster: JetFireFeatureToaster {
    get {return _storage._toaster ?? JetFireFeatureToaster()}
    set {_uniqueStorage()._toaster = newValue}
  }
  /// Returns true if `toaster` has been explicitly set.
  public var hasToaster: Bool {return _storage._toaster != nil}
  /// Clears the value of `toaster`. Subsequent reads from it will return its default value.
  public mutating func clearToaster() {_uniqueStorage()._toaster = nil}

  public var stories: [JetFireFeatureStory] {
    get {return _storage._stories}
    set {_uniqueStorage()._stories = newValue}
  }

  public var data: JetFireFeatureData {
    get {return _storage._data ?? JetFireFeatureData()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var priority: Int32 {
    get {return _storage._priority ?? 0}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  public var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  public mutating func clearPriority() {_uniqueStorage()._priority = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct JetFireListCampaignsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: JetFireUser {
    get {return _user ?? JetFireUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireSession {
    get {return _session ?? JetFireSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: JetFireUser? = nil
  fileprivate var _session: JetFireSession? = nil
}

public struct JetFireUpdateUserProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var propertyOperations: [JetFirePropertyOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
}

public struct JetFireUpdateSessionProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var propertyOperations: [JetFirePropertyOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
}

public struct JetFireRegisterEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var events: [JetFireEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
}

public struct JetFireListCampaignsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var total: Int32 {
    get {return _total ?? 0}
    set {_total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  public var hasTotal: Bool {return self._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  public mutating func clearTotal() {self._total = nil}

  public var campaigns: [JetFireCampaign] = []

  public var sql: JetFireFeaturesSql {
    get {return _sql ?? JetFireFeaturesSql()}
    set {_sql = newValue}
  }
  /// Returns true if `sql` has been explicitly set.
  public var hasSql: Bool {return self._sql != nil}
  /// Clears the value of `sql`. Subsequent reads from it will return its default value.
  public mutating func clearSql() {self._sql = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _total: Int32? = nil
  fileprivate var _sql: JetFireFeaturesSql? = nil
}

public struct JetFireOkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 {
    get {return _code ?? 0}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  public var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  public mutating func clearCode() {self._code = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _code: Int32? = nil
}

public struct JetFireErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 {
    get {return _code ?? 0}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  public var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  public mutating func clearCode() {self._code = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var systemMessage: String {
    get {return _systemMessage ?? String()}
    set {_systemMessage = newValue}
  }
  /// Returns true if `systemMessage` has been explicitly set.
  public var hasSystemMessage: Bool {return self._systemMessage != nil}
  /// Clears the value of `systemMessage`. Subsequent reads from it will return its default value.
  public mutating func clearSystemMessage() {self._systemMessage = nil}

  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _code: Int32? = nil
  fileprivate var _message: String? = nil
  fileprivate var _systemMessage: String? = nil
  fileprivate var _type: String? = nil
}

public struct JetFireJwt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String {
    get {return _token ?? String()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: String? = nil
}

public struct JetFireRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ip: String {
    get {return _ip ?? String()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  public var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  public mutating func clearIp() {self._ip = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ip: String? = nil
}

public struct JetFireRegisterUserAndSessionMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: JetFireJwt {
    get {return _jwt ?? JetFireJwt()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  public var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  public mutating func clearJwt() {self._jwt = nil}

  public var salt: String {
    get {return _salt ?? String()}
    set {_salt = newValue}
  }
  /// Returns true if `salt` has been explicitly set.
  public var hasSalt: Bool {return self._salt != nil}
  /// Clears the value of `salt`. Subsequent reads from it will return its default value.
  public mutating func clearSalt() {self._salt = nil}

  public var request: JetFireRequest {
    get {return _request ?? JetFireRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var user: JetFireUser {
    get {return _user ?? JetFireUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireSession {
    get {return _session ?? JetFireSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jwt: JetFireJwt? = nil
  fileprivate var _salt: String? = nil
  fileprivate var _request: JetFireRequest? = nil
  fileprivate var _user: JetFireUser? = nil
  fileprivate var _session: JetFireSession? = nil
}

public struct JetFireUpdateUserPropertiesMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: JetFireJwt {
    get {return _jwt ?? JetFireJwt()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  public var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  public mutating func clearJwt() {self._jwt = nil}

  public var salt: String {
    get {return _salt ?? String()}
    set {_salt = newValue}
  }
  /// Returns true if `salt` has been explicitly set.
  public var hasSalt: Bool {return self._salt != nil}
  /// Clears the value of `salt`. Subsequent reads from it will return its default value.
  public mutating func clearSalt() {self._salt = nil}

  public var request: JetFireRequest {
    get {return _request ?? JetFireRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var propertyOperations: [JetFirePropertyOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jwt: JetFireJwt? = nil
  fileprivate var _salt: String? = nil
  fileprivate var _request: JetFireRequest? = nil
  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
}

public struct JetFireUpdateSessionPropertiesMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: JetFireJwt {
    get {return _jwt ?? JetFireJwt()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  public var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  public mutating func clearJwt() {self._jwt = nil}

  public var salt: String {
    get {return _salt ?? String()}
    set {_salt = newValue}
  }
  /// Returns true if `salt` has been explicitly set.
  public var hasSalt: Bool {return self._salt != nil}
  /// Clears the value of `salt`. Subsequent reads from it will return its default value.
  public mutating func clearSalt() {self._salt = nil}

  public var request: JetFireRequest {
    get {return _request ?? JetFireRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var propertyOperations: [JetFirePropertyOperation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jwt: JetFireJwt? = nil
  fileprivate var _salt: String? = nil
  fileprivate var _request: JetFireRequest? = nil
  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
}

public struct JetFireEventMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jwt: JetFireJwt {
    get {return _jwt ?? JetFireJwt()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  public var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  public mutating func clearJwt() {self._jwt = nil}

  public var salt: String {
    get {return _salt ?? String()}
    set {_salt = newValue}
  }
  /// Returns true if `salt` has been explicitly set.
  public var hasSalt: Bool {return self._salt != nil}
  /// Clears the value of `salt`. Subsequent reads from it will return its default value.
  public mutating func clearSalt() {self._salt = nil}

  public var request: JetFireRequest {
    get {return _request ?? JetFireRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var user: JetFireRequestUser {
    get {return _user ?? JetFireRequestUser()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var session: JetFireRequestSession {
    get {return _session ?? JetFireRequestSession()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var event: JetFireEvent {
    get {return _event ?? JetFireEvent()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jwt: JetFireJwt? = nil
  fileprivate var _salt: String? = nil
  fileprivate var _request: JetFireRequest? = nil
  fileprivate var _user: JetFireRequestUser? = nil
  fileprivate var _session: JetFireRequestSession? = nil
  fileprivate var _event: JetFireEvent? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension JetFireTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Timestamp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireTimestamp, rhs: JetFireTimestamp) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireEventType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireEventType, rhs: JetFireEventType) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireActionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ActionType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._value {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireActionType, rhs: JetFireActionType) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireAnyValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AnyValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "int"),
    102: .same(proto: "long"),
    103: .same(proto: "double"),
    104: .same(proto: "bool"),
    105: .same(proto: "string"),
    106: .same(proto: "json"),
    107: .same(proto: "bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try { try decoder.decodeSingularInt32Field(value: &self._int) }()
      case 102: try { try decoder.decodeSingularInt64Field(value: &self._long) }()
      case 103: try { try decoder.decodeSingularDoubleField(value: &self._double) }()
      case 104: try { try decoder.decodeSingularBoolField(value: &self._bool) }()
      case 105: try { try decoder.decodeSingularStringField(value: &self._string) }()
      case 106: try { try decoder.decodeSingularStringField(value: &self._json) }()
      case 107: try { try decoder.decodeSingularBytesField(value: &self._bytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._int {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 101)
    }
    if let v = self._long {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 102)
    }
    if let v = self._double {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 103)
    }
    if let v = self._bool {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 104)
    }
    if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 105)
    }
    if let v = self._json {
      try visitor.visitSingularStringField(value: v, fieldNumber: 106)
    }
    if let v = self._bytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 107)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireAnyValue, rhs: JetFireAnyValue) -> Bool {
    if lhs._int != rhs._int {return false}
    if lhs._long != rhs._long {return false}
    if lhs._double != rhs._double {return false}
    if lhs._bool != rhs._bool {return false}
    if lhs._string != rhs._string {return false}
    if lhs._json != rhs._json {return false}
    if lhs._bytes != rhs._bytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
  ]

  public var isInitialized: Bool {
    if self._lat == nil {return false}
    if self._lon == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._lon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lat {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }
    if let v = self._lon {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireLocation, rhs: JetFireLocation) -> Bool {
    if lhs._lat != rhs._lat {return false}
    if lhs._lon != rhs._lon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireScreen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "dpi"),
  ]

  public var isInitialized: Bool {
    if self._width == nil {return false}
    if self._height == nil {return false}
    if self._dpi == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._dpi) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._dpi {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireScreen, rhs: JetFireScreen) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._dpi != rhs._dpi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireProperty, rhs: JetFireProperty) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preview_url"),
    2: .same(proto: "url"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._previewURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._previewURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireImage, rhs: JetFireImage) -> Bool {
    if lhs._previewURL != rhs._previewURL {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "deeplink"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self._type, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._deeplink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._deeplink {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireAction, rhs: JetFireAction) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._deeplink != rhs._deeplink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "at_time"),
    2: .same(proto: "after"),
  ]

  public var isInitialized: Bool {
    if let v = self._atTime, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._atTime) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._after) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._atTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._after {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireSchedule, rhs: JetFireSchedule) -> Bool {
    if lhs._atTime != rhs._atTime {return false}
    if lhs._after != rhs._after {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFirePropertySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertySet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFirePropertySet, rhs: JetFirePropertySet) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFirePropertyRemove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyRemove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFirePropertyRemove, rhs: JetFirePropertyRemove) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFirePropertyIncrement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyIncrement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "increment"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._increment == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._increment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._increment {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFirePropertyIncrement, rhs: JetFirePropertyIncrement) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._increment != rhs._increment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFirePropertyDecrement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyDecrement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "decrement"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._decrement == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._decrement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._decrement {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFirePropertyDecrement, rhs: JetFirePropertyDecrement) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._decrement != rhs._decrement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFirePropertyOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PropertyOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "set"),
    3: .same(proto: "remove"),
    4: .same(proto: "increment"),
    5: .same(proto: "decrement"),
  ]

  public var isInitialized: Bool {
    if let v = self.operation, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: JetFirePropertySet?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .set(v)
        }
      }()
      case 3: try {
        var v: JetFirePropertyRemove?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .remove(v)
        }
      }()
      case 4: try {
        var v: JetFirePropertyIncrement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .increment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .increment(v)
        }
      }()
      case 5: try {
        var v: JetFirePropertyDecrement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .decrement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .decrement(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.operation {
    case .set?: try {
      guard case .set(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .increment?: try {
      guard case .increment(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .decrement?: try {
      guard case .decrement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFirePropertyOperation, rhs: JetFirePropertyOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "App"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "version"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireApp, rhs: JetFireApp) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireSdk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Sdk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "version"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireSdk, rhs: JetFireSdk) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "platform"),
    3: .same(proto: "vendor"),
    4: .same(proto: "model"),
    5: .same(proto: "os"),
    6: .standard(proto: "os_version"),
    7: .same(proto: "firmware"),
    8: .same(proto: "language"),
    9: .same(proto: "locale"),
    10: .standard(proto: "time_zone"),
    11: .same(proto: "carrier"),
    12: .same(proto: "screen"),
  ]

  public var isInitialized: Bool {
    if self._platform == nil {return false}
    if self._vendor == nil {return false}
    if self._model == nil {return false}
    if self._os == nil {return false}
    if self._osVersion == nil {return false}
    if self._language == nil {return false}
    if self._locale == nil {return false}
    if self._timeZone == nil {return false}
    if self._screen == nil {return false}
    if let v = self._screen, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._vendor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._model) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._os) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._osVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._firmware) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._locale) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._timeZone) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.carrier) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._platform {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._vendor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._model {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._os {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._osVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._firmware {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._locale {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if let v = self._timeZone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    if !self.carrier.isEmpty {
      try visitor.visitRepeatedStringField(value: self.carrier, fieldNumber: 11)
    }
    if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireDevice, rhs: JetFireDevice) -> Bool {
    if lhs._platform != rhs._platform {return false}
    if lhs._vendor != rhs._vendor {return false}
    if lhs._model != rhs._model {return false}
    if lhs._os != rhs._os {return false}
    if lhs._osVersion != rhs._osVersion {return false}
    if lhs._firmware != rhs._firmware {return false}
    if lhs._language != rhs._language {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs._timeZone != rhs._timeZone {return false}
    if lhs.carrier != rhs.carrier {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireRequestUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireRequestUser, rhs: JetFireRequestUser) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
    3: .same(proto: "properties"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireUser, rhs: JetFireUser) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireRequestSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestSession"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireRequestSession, rhs: JetFireRequestSession) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "app"),
    5: .same(proto: "sdk"),
    6: .same(proto: "device"),
    7: .same(proto: "location"),
    8: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String? = nil
    var _timestamp: JetFireTimestamp? = nil
    var _app: JetFireApp? = nil
    var _sdk: JetFireSdk? = nil
    var _device: JetFireDevice? = nil
    var _location: JetFireLocation? = nil
    var _properties: [JetFireProperty] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _timestamp = source._timestamp
      _app = source._app
      _sdk = source._sdk
      _device = source._device
      _location = source._location
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._uuid == nil {return false}
      if _storage._timestamp == nil {return false}
      if _storage._app == nil {return false}
      if _storage._sdk == nil {return false}
      if _storage._device == nil {return false}
      if let v = _storage._timestamp, !v.isInitialized {return false}
      if let v = _storage._app, !v.isInitialized {return false}
      if let v = _storage._sdk, !v.isInitialized {return false}
      if let v = _storage._device, !v.isInitialized {return false}
      if let v = _storage._location, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._properties) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sdk) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._properties) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._uuid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._sdk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireSession, rhs: JetFireSession) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._sdk != rhs_storage._sdk {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._properties != rhs_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeaturesSql: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeaturesSql"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "stories"),
    3: .same(proto: "trigger"),
  ]

  public var isInitialized: Bool {
    if self._stories == nil {return false}
    if self._trigger == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._stories) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._trigger) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stories {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._trigger {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeaturesSql, rhs: JetFireFeaturesSql) -> Bool {
    if lhs._stories != rhs._stories {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureButton: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureButton"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "title"),
    3: .same(proto: "action"),
  ]

  public var isInitialized: Bool {
    if let v = self._action, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureButton, rhs: JetFireFeatureButton) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeaturePush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeaturePush"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "message"),
    5: .same(proto: "image"),
    6: .standard(proto: "action_button"),
    7: .same(proto: "schedule"),
    8: .same(proto: "expire"),
  ]

  public var isInitialized: Bool {
    if let v = self._image, !v.isInitialized {return false}
    if let v = self._actionButton, !v.isInitialized {return false}
    if let v = self._schedule, !v.isInitialized {return false}
    if let v = self._expire, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._subtitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._actionButton) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._expire) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._subtitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._actionButton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._expire {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeaturePush, rhs: JetFireFeaturePush) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._subtitle != rhs._subtitle {return false}
    if lhs._message != rhs._message {return false}
    if lhs._image != rhs._image {return false}
    if lhs._actionButton != rhs._actionButton {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._expire != rhs._expire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureToaster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureToaster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "message"),
    5: .same(proto: "image"),
    6: .standard(proto: "action_button"),
    7: .standard(proto: "hide_button"),
    8: .same(proto: "schedule"),
    9: .same(proto: "expire"),
  ]

  public var isInitialized: Bool {
    if let v = self._image, !v.isInitialized {return false}
    if let v = self._actionButton, !v.isInitialized {return false}
    if let v = self._hideButton, !v.isInitialized {return false}
    if let v = self._schedule, !v.isInitialized {return false}
    if let v = self._expire, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._subtitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._actionButton) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._hideButton) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._expire) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._subtitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._actionButton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._hideButton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._expire {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureToaster, rhs: JetFireFeatureToaster) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._subtitle != rhs._subtitle {return false}
    if lhs._message != rhs._message {return false}
    if lhs._image != rhs._image {return false}
    if lhs._actionButton != rhs._actionButton {return false}
    if lhs._hideButton != rhs._hideButton {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._expire != rhs._expire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStoryFrameBackground: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStoryFrameBackground"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._color {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStoryFrameBackground, rhs: JetFireFeatureStoryFrameBackground) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStoryFrameFont: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStoryFrameFont"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._color {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStoryFrameFont, rhs: JetFireFeatureStoryFrameFont) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStoryCover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStoryCover"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "image"),
    3: .same(proto: "title"),
  ]

  public var isInitialized: Bool {
    if let v = self._image, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStoryCover, rhs: JetFireFeatureStoryCover) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStorySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStorySettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "always_rewind"),
    3: .standard(proto: "after_read_expire"),
  ]

  public var isInitialized: Bool {
    if self._alwaysRewind == nil {return false}
    if self._afterReadExpire == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self._alwaysRewind) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._afterReadExpire) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._alwaysRewind {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._afterReadExpire {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStorySettings, rhs: JetFireFeatureStorySettings) -> Bool {
    if lhs._alwaysRewind != rhs._alwaysRewind {return false}
    if lhs._afterReadExpire != rhs._afterReadExpire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStoryFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStoryFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "message"),
    5: .same(proto: "image"),
    6: .same(proto: "background"),
    7: .same(proto: "font"),
    8: .standard(proto: "action_button"),
    9: .standard(proto: "hide_button"),
    10: .same(proto: "duration"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._duration == nil {return false}
    if let v = self._image, !v.isInitialized {return false}
    if let v = self._actionButton, !v.isInitialized {return false}
    if let v = self._hideButton, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._subtitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._background) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._font) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._actionButton) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._hideButton) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._subtitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._background {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._font {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._actionButton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._hideButton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._duration {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStoryFrame, rhs: JetFireFeatureStoryFrame) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._title != rhs._title {return false}
    if lhs._subtitle != rhs._subtitle {return false}
    if lhs._message != rhs._message {return false}
    if lhs._image != rhs._image {return false}
    if lhs._background != rhs._background {return false}
    if lhs._font != rhs._font {return false}
    if lhs._actionButton != rhs._actionButton {return false}
    if lhs._hideButton != rhs._hideButton {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureStory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureStory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "cover"),
    3: .same(proto: "frames"),
    4: .same(proto: "schedule"),
    5: .same(proto: "expire"),
    6: .same(proto: "settings"),
    7: .same(proto: "priority"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._settings == nil {return false}
    if self._priority == nil {return false}
    if let v = self._cover, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.frames) {return false}
    if let v = self._schedule, !v.isInitialized {return false}
    if let v = self._expire, !v.isInitialized {return false}
    if let v = self._settings, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cover) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.frames) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expire) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._priority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._cover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.frames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frames, fieldNumber: 3)
    }
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._expire {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._priority {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureStory, rhs: JetFireFeatureStory) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._cover != rhs._cover {return false}
    if lhs.frames != rhs.frames {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._expire != rhs._expire {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs._priority != rhs._priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireFeatureData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FeatureData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "data"),
    3: .same(proto: "schedule"),
    4: .same(proto: "expire"),
  ]

  public var isInitialized: Bool {
    if self._data == nil {return false}
    if let v = self._schedule, !v.isInitialized {return false}
    if let v = self._expire, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expire) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._expire {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireFeatureData, rhs: JetFireFeatureData) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._expire != rhs._expire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "uuid"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "event_type"),
    5: .standard(proto: "custom_event"),
    6: .same(proto: "feature"),
    7: .standard(proto: "campaign_id"),
    8: .standard(proto: "entity_id"),
    9: .same(proto: "properties"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if self._timestamp == nil {return false}
    if self._eventType == nil {return false}
    if let v = self._timestamp, !v.isInitialized {return false}
    if let v = self._eventType, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.properties) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._uuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._eventType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._customEvent) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._feature) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._campaignID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self._entityID) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._eventType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._customEvent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._feature {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._campaignID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._entityID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireEvent, rhs: JetFireEvent) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._eventType != rhs._eventType {return false}
    if lhs._customEvent != rhs._customEvent {return false}
    if lhs._feature != rhs._feature {return false}
    if lhs._campaignID != rhs._campaignID {return false}
    if lhs._entityID != rhs._entityID {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Campaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "push"),
    3: .same(proto: "toaster"),
    4: .same(proto: "stories"),
    5: .same(proto: "data"),
    6: .same(proto: "priority"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64? = nil
    var _push: JetFireFeaturePush? = nil
    var _toaster: JetFireFeatureToaster? = nil
    var _stories: [JetFireFeatureStory] = []
    var _data: JetFireFeatureData? = nil
    var _priority: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _push = source._push
      _toaster = source._toaster
      _stories = source._stories
      _data = source._data
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id == nil {return false}
      if _storage._priority == nil {return false}
      if let v = _storage._push, !v.isInitialized {return false}
      if let v = _storage._toaster, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stories) {return false}
      if let v = _storage._data, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._push) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._toaster) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._stories) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._push {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._toaster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._stories.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stories, fieldNumber: 4)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._priority {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireCampaign, rhs: JetFireCampaign) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._push != rhs_storage._push {return false}
        if _storage._toaster != rhs_storage._toaster {return false}
        if _storage._stories != rhs_storage._stories {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireListCampaignsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ListCampaignsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "user"),
    4: .same(proto: "session"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireListCampaignsRequest, rhs: JetFireListCampaignsRequest) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireUpdateUserProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "user"),
    3: .same(proto: "session"),
    4: .standard(proto: "property_operations"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.propertyOperations) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.propertyOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.propertyOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyOperations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireUpdateUserProperties, rhs: JetFireUpdateUserProperties) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.propertyOperations != rhs.propertyOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireUpdateSessionProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateSessionProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "user"),
    3: .same(proto: "session"),
    4: .standard(proto: "property_operations"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.propertyOperations) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.propertyOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.propertyOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyOperations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireUpdateSessionProperties, rhs: JetFireUpdateSessionProperties) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.propertyOperations != rhs.propertyOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireRegisterEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RegisterEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "user"),
    3: .same(proto: "session"),
    4: .same(proto: "events"),
  ]

  public var isInitialized: Bool {
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.events) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireRegisterEventsRequest, rhs: JetFireRegisterEventsRequest) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireListCampaignsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ListCampaignsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "total"),
    3: .same(proto: "campaigns"),
    4: .same(proto: "sql"),
  ]

  public var isInitialized: Bool {
    if self._total == nil {return false}
    if self._sql == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.campaigns) {return false}
    if let v = self._sql, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._total) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.campaigns) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sql) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._total {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if !self.campaigns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.campaigns, fieldNumber: 3)
    }
    if let v = self._sql {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireListCampaignsResponse, rhs: JetFireListCampaignsResponse) -> Bool {
    if lhs._total != rhs._total {return false}
    if lhs.campaigns != rhs.campaigns {return false}
    if lhs._sql != rhs._sql {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireOkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OkResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "code"),
  ]

  public var isInitialized: Bool {
    if self._code == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._code {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireOkResponse, rhs: JetFireOkResponse) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "code"),
    3: .same(proto: "message"),
    4: .standard(proto: "system_message"),
    5: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._code == nil {return false}
    if self._message == nil {return false}
    if self._type == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._systemMessage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._code {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._systemMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireErrorResponse, rhs: JetFireErrorResponse) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs._message != rhs._message {return false}
    if lhs._systemMessage != rhs._systemMessage {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireJwt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Jwt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "token"),
  ]

  public var isInitialized: Bool {
    if self._token == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireJwt, rhs: JetFireJwt) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._ip) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ip {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireRequest, rhs: JetFireRequest) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireRegisterUserAndSessionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RegisterUserAndSessionMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "jwt"),
    3: .same(proto: "salt"),
    4: .same(proto: "request"),
    5: .same(proto: "user"),
    6: .same(proto: "session"),
  ]

  public var isInitialized: Bool {
    if self._jwt == nil {return false}
    if self._salt == nil {return false}
    if self._request == nil {return false}
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._jwt, !v.isInitialized {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jwt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._salt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._salt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireRegisterUserAndSessionMessage, rhs: JetFireRegisterUserAndSessionMessage) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs._salt != rhs._salt {return false}
    if lhs._request != rhs._request {return false}
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireUpdateUserPropertiesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserPropertiesMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "jwt"),
    3: .same(proto: "salt"),
    4: .same(proto: "request"),
    5: .same(proto: "user"),
    6: .same(proto: "session"),
    7: .standard(proto: "property_operations"),
  ]

  public var isInitialized: Bool {
    if self._jwt == nil {return false}
    if self._salt == nil {return false}
    if self._request == nil {return false}
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._jwt, !v.isInitialized {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.propertyOperations) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jwt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._salt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.propertyOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._salt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.propertyOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyOperations, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireUpdateUserPropertiesMessage, rhs: JetFireUpdateUserPropertiesMessage) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs._salt != rhs._salt {return false}
    if lhs._request != rhs._request {return false}
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.propertyOperations != rhs.propertyOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireUpdateSessionPropertiesMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateSessionPropertiesMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "jwt"),
    3: .same(proto: "salt"),
    4: .same(proto: "request"),
    5: .same(proto: "user"),
    6: .same(proto: "session"),
    7: .standard(proto: "property_operations"),
  ]

  public var isInitialized: Bool {
    if self._jwt == nil {return false}
    if self._salt == nil {return false}
    if self._request == nil {return false}
    if self._user == nil {return false}
    if self._session == nil {return false}
    if let v = self._jwt, !v.isInitialized {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.propertyOperations) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jwt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._salt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.propertyOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._salt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.propertyOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyOperations, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireUpdateSessionPropertiesMessage, rhs: JetFireUpdateSessionPropertiesMessage) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs._salt != rhs._salt {return false}
    if lhs._request != rhs._request {return false}
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs.propertyOperations != rhs.propertyOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JetFireEventMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EventMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "jwt"),
    3: .same(proto: "salt"),
    4: .same(proto: "request"),
    5: .same(proto: "user"),
    6: .same(proto: "session"),
    7: .same(proto: "event"),
  ]

  public var isInitialized: Bool {
    if self._jwt == nil {return false}
    if self._salt == nil {return false}
    if self._request == nil {return false}
    if self._user == nil {return false}
    if self._session == nil {return false}
    if self._event == nil {return false}
    if let v = self._jwt, !v.isInitialized {return false}
    if let v = self._user, !v.isInitialized {return false}
    if let v = self._session, !v.isInitialized {return false}
    if let v = self._event, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._jwt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._salt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._salt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: JetFireEventMessage, rhs: JetFireEventMessage) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs._salt != rhs._salt {return false}
    if lhs._request != rhs._request {return false}
    if lhs._user != rhs._user {return false}
    if lhs._session != rhs._session {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
